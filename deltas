#!/usr/bin/perl -w
#
# Copyright 2014 (c) Kolbe Kegel
#
# Author: Kolbe Kegel <kolbe@kolbekegel.com>
#
# This file is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the
# Free Software Foundation, version 2.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use strict;

# egrep 'Handler_(read|update)' qa/qa_update.log | tr -d '|' | deltas | column -t
# cat global_0508121* | deltas -v | egrep -v '\+0\b' | column -t

# Use -h as the first argument if you want vertical output, otherwise you get vertical


my %v;
my $output = "v";
if (defined $ARGV[0]) {
    if ("$ARGV[0]" eq "-h") {
        $output = "h";
    } 
    shift if $ARGV[0] =~ /^-/ && $ARGV[0] ne "--";
}

while (<>) {
    my @F = split(' ');
    push @{$v{$F[0]}}, $F[1]; 
}

sub prn($$) {
    my $n = shift;
    my $v = shift;
    my $p = $n > 0 ? "+" : "";
    printf "%${p}d\t", $v->[$n] - ($n ? $v->[$n-1] : 0), "\t";
}

my @k = sort keys %v;
if ($output eq "v") {
    for my $k (@k) {
        print "$k\t";
        for (my $n=0; $n < @{$v{$k}}; $n++) {
            prn($n,$v{$k})
        }
        print "\n";
    }
} else {
    print join "\t", @k;
    print "\n";
    for (my $n=0; $n < @{$v{$k[0]}}; $n++) { 
        my $p = $n > 0 ? "+" : "";
        for my $k (@k) { 
            prn($n,$v{$k})
        } 
        print "\n";
    }  
}
